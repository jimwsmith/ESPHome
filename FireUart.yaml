
external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 10ms
  tx_delay: 50ms
  tx_timeout: 500ms
  tx_retry_cnt: 3
  rx_priority: loop #Lower priority for Rx than main loop tasks
  # rx_header: [0x02, 0x01]
  rx_footer: [0x0D, 0x0A]
  # tx_header: [0x02, 0x01]
  tx_footer: [0x0D, 0x0A]

  version:
    name: "Uartex Version"
    disabled: False
  error:
    name: "Uartex Error"
    disabled: False
  log:
    name: "Uartex Log"
    disabled: True #False

sensor: 
  - platform: uartex
    id: atmega_uptime
    name: "ATMega Uptime"
    entity_category: "diagnostic"
    unit_of_measurement: "m"
    state: "H1"
    state_number:
      offset: 2
      length: 16 #If value received is shorter than this, decoding seems OK
      precision: 0
      decode: "ascii"
    accuracy_decimals: 0
    # device_class: "duration"

  - platform: uartex
    id: atmega_button_counter
    name: "ATMega Button Counter"
    unit_of_measurement: "units"
    state: "B2"
    state_number:
      offset: 2
      length: 16 #If value received is shorter than this, decoding seems OK
      precision: 0
      decode: "ascii"
    accuracy_decimals: 0

  - platform: uartex
    id: ve_bmv_soc
    name: "Battery SOC"
    device_class: "battery"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VE01"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_bmv_voltage
    name: "Battery Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE02"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_bmv_startv
    name: "Starter Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE03"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_bmv_power
    name: "Battery Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state: "VE04"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_bmv_current
    name: "Battery Current"
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 2
    state: "VE05"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_bmv_alarm
    name: "Battery Alarm"
    unit_of_measurement: "units"
    accuracy_decimals: 0
    state: "VE06"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_bmv_relay
    name: "Battery Relay"
    unit_of_measurement: "units"
    accuracy_decimals: 0
    state: "VE07"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_mptt_voltage
    name: "MPTT Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE08"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_mptt_panel_voltage
    name: "Solar Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE09"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_mppt_power
    name: "Solar Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state: "VE10"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: ve_mptt_current
    name: "Solar Current"
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 2
    state: "VE11"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;



#   - platform: uartex
#     id: test_sensor_4
#     name: "Test Sensor 4"
#     unit_of_measurement: "units"
#     accuracy_decimals: 3
#     state: "V4"
#     lambda: |-
#       auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+2), len-2));
#       return n.has_value() ? n.value() : NAN;

#   - platform: uartex
#     id: test_sensor_5
#     name: "Test Sensor 5"
#     unit_of_measurement: "units"
#     accuracy_decimals: 3
#     state: "V5"
#     lambda: |-
#       std::string str =  std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply 
#       auto n = parse_number<float>(str);
#       return n.has_value() ? n.value() : NAN;

text_sensor:
  - platform: uartex
    id: test_text_sensor
    name: "Test Text Sensor"
    state: "T1"
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars
  - platform: uartex
    id: atmega_info
    name: "ATMega Info"
    entity_category: "diagnostic"
    state: "T2"
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars

binary_sensor:
  - platform: uartex
    state: "B1"
    state_on:
      offset: 2
      data: [0x31] # ASCII '1'
    state_off:
      offset: 2
      data: [0x30] # ASCII '0'
    name: "ATMega Button"
