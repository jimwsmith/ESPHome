substitutions:
  devicename: boat
  tx_pin: GPIO1
  rx_pin: GPIO3
  led_pin: GPIO14
  button_pin: GPIO13
  sensor_update: 60s
  led_strbuf_size: "16"

# Global Variables
# globals:
#   - id: my_global_int
#     type: int
#     restore_value: no #on the ESP8266, you only have a total of 96 bytes available for this! Defaults to no.
#     initial_value: '0'

esphome:
  name: $devicename
  on_boot: 
    - priority: 600 #Uart should be configured before this runs
      then:
        - uart.write: "\r\n" #clear out any partial data sent as Uart started so that LED setup string will be interpreted OK
    - priority: -100 #run this very late in the boot process
      then:
        - uart.write: "\r\n" #clear out any partial data sent as Uart started
        - uart.write: "Info\r\n" #Requesting version info from AT Mega on boot"
      

esp8266:
  board: esp07s #d1_mini_pro

packages: 
  uart: !include AinsleyUart.yaml

uart:
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1
  tx_pin: $tx_pin
  rx_pin: $rx_pin
  rx_buffer_size: 512

number:
  - platform: template
    id: wifi_error_count
    name: "WiFi Error Count"
    unit_of_measurement: "errors"
    entity_category: "diagnostic"
    max_value: 1000000
    min_value: 0  
    step: 1
    optimistic: true  
  - platform: template
    id: mqtt_error_count
    name: "MQTT Error Count"
    entity_category: "diagnostic"
    unit_of_measurement: "errors"
    max_value: 1000000
    min_value: 0  
    step: 1
    optimistic: true  

wifi:
  networks:
    - ssid: !secret wifi_comp_ssid
      password: !secret wifi_comp_password
    - ssid: !secret wifi_home_ssid
      password: !secret wifi_home_password
    - ssid: !secret wifi_phone_ssid
      password: !secret wifi_phone_password
    - ssid: !secret wifi_bshed_ssid
      password: !secret wifi_bshed_password
  # on_connect:
    # - uart.write: "\n\nESP8266 Reboot, WiFi connected\r\n"
  on_disconnect:
    # - uart.write: "\nWiFi disconnected\r\n"
    - number.increment:
        id: wifi_error_count
    
interval:
  - interval: $sensor_update
    then: #publish wifi info every sensor_update interval as it is not valid when WiFi first starts up
      - mqtt.publish:
          topic: $devicename/sensor/wifi_ssid/state
          payload: !lambda |-
            return id(wifi_ssid).state;
      - mqtt.publish:
          topic: $devicename/sensor/wifi_dns/state
          payload: !lambda |-
            return id(wifi_dns).state;
      - mqtt.publish:
          topic: $devicename/sensor/wifi_ip/state
          payload: !lambda |-
            return id(wifi_ip).state;

mqtt:
  broker: allsmiths.synology.me
  port: 1883
  username: !secret mqtt_username
  password: !secret mqtt_password
  #no clientid reqd
  discovery: true # disable entity discovery
  discover_ip: true # enable device discovery
  discovery_retain: true #retain discovery messages
  discovery_unique_id_generator: mac #Use Mac address to generate unique entity Ids
  # on_connect:
    # - uart.write: "\nMQTT connected\r\n"
  on_disconnect:
    # - uart.write: "\nMQTT disconnected\r\n"
    - number.increment:
        id: mqtt_error_count
  keepalive: 15s # default is 15s apparently but I had to set to 10s to prevent frequent MQTT disconnects

ota:
  platform: esphome

logger:
  baud_rate: 0 # disable uart logging (MQTT logging still happens) as we need to retain the serial port free for comms with AT Mega
  level: DEBUG

button: 
  - platform: restart #virtual button to remotely reboot device
    id: restart_button
    name: Restart

light:
  - platform: status_led #Built in LED to show status for SP8266
    name: "ESP8266 LED"
    id: devicename_led
    pin: 
      number: $led_pin
      inverted: False
    restore_mode: RESTORE_DEFAULT_ON

  - platform: rgb #Individual control of RGB elemenst of LED strip driven from AT Mega via ESP8266
    name: "ATMega RGB Light"
    id: ainsley_rgb_light
    red: output_red
    green: output_green
    blue: output_blue
    default_transition_length: 0s #instant change of colour as we cannot cope with transitions
    restore_mode: RESTORE_DEFAULT_OFF

output:
# Consider adding \r\n at start of each command if issues arise with LED control
  - platform: template
    id: output_red
    type: float
    write_action:
      - logger.log:
          format: "Setting RED output to %.2f"
          args: [ 'state' ]
      - uart.write: !lambda  |-
          char buf[$led_strbuf_size];
          snprintf(buf, $led_strbuf_size, "LR%02X\r\n", (int)(255*state)); //Send colour value to AT Mega
          std::string s = buf;
          return std::vector<unsigned char>( s.begin(), s.end() );
  - platform: template
    id: output_green
    type: float
    write_action:
      - uart.write: !lambda  |-
          char buf[$led_strbuf_size];
          snprintf(buf, $led_strbuf_size, "LG%02X\r\n", (int)(255*state)); //Send colour value to AT Mega
          std::string s = buf;
          return std::vector<unsigned char>( s.begin(), s.end() );
  - platform: template
    id: output_blue
    type: float
    write_action:
      - uart.write: !lambda  |-
          char buf[$led_strbuf_size];
          snprintf(buf, $led_strbuf_size, "LB%02X\r\n", (int)(255*state)); //Send colour value to AT Mega
          std::string s = buf;
          return std::vector<unsigned char>( s.begin(), s.end() );

sensor:
  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    icon: mdi:wifi
    name: "WiFi Signal dB"
    id: wifi_signal_db
    unit_of_measurement: "dB"
    update_interval: ${sensor_update}
    entity_category: "diagnostic"
                
  - platform: uptime
    name: "Uptime"

text_sensor:
  - platform: wifi_info
    ssid:
      icon: mdi:wifi
      id: wifi_ssid
      name: "WiFi SSID"
    dns_address:
      icon: mdi:wifi
      id: wifi_dns
      name: "WiFi DNS"
    ip_address:
      icon: mdi:wifi
      id: wifi_ip
      name: "WiFi IP"

binary_sensor:
  - platform: gpio
    pin: 
      number: $button_pin
      inverted: True
    name: "ESP8266 Button"