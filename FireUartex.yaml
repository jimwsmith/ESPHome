
external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 10ms
  tx_delay: 50ms
  tx_timeout: 500ms
  tx_retry_cnt: 3
  # rx_priority: loop #Lower priority for Rx than main loop tasks
  # rx_header: [0x02, 0x01]
  rx_footer: [0x0D, 0x0A]
  # tx_header: [0x02, 0x01]
  tx_footer: [0x0D, 0x0A]

  version:
    name: "Uartex Version"
    disabled: False
  error:
    name: "Uartex Error"
    disabled: False
  log:
    name: "Uartex Log"
    disabled: True #False

sensor: 
  - platform: uartex
    id: atmega_uptime
    name: "ATMega Uptime"
    entity_category: "diagnostic"
    unit_of_measurement: "m"
    state: "H1"
    state_number:
      offset: 2
      length: 16 #If value received is shorter than this, decoding seems OK
      precision: 0
      decode: "ascii"
    accuracy_decimals: 0
    # device_class: "duration"

  - platform: uartex
    id: atmega_button_counter
    name: "ATMega Button Counter"
    unit_of_measurement: "units"
    state: "B2"
    state_number:
      offset: 2
      length: 16 #If value received is shorter than this, decoding seems OK
      precision: 0
      decode: "ascii"
    accuracy_decimals: 0

  - platform: uartex
    id: vb_dc_battery_voltage
    name: "DC Battery Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 1
    state: "VB01"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_dc_inverter_current
    name: "DC Inverter Current"    
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 1
    state: "VB02"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_dc_charger_current
    name: "DC Charger Current"
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 1
    state: "VB03"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  # - platform: uartex
  #   id: vb_inverter_frequency
  #   name: "Inverter Frequency"
  #   device_class: "frequency"
  #   unit_of_measurement: "Hz"
  #   accuracy_decimals: 1
  #   state: "VB04"
  #   state_number:
  #     offset: 4
  #     length: $float_length 
  #     decode: "ascii"

  - platform: uartex
    id: vb_dc_power
    name: "DC Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state: "VB05"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_ac_mains_voltage
    name: "AC Mains Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 1
    state: "VB06"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_ac_mains_current
    name: "AC Mains Current"    
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 1
    state: "VB07"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_ac_power
    name: "AC Mains Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state: "VB08"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_ac_inverter_voltage
    name: "AC Inverter Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 1
    state: "VB09"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_ac_inverter_current
    name: "AC Inverter Current"    
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 1
    state: "VB10"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  # - platform: uartex
  #   id: vb_mains_frequency
  #   name: "Mains Frequency"
  #   device_class: "frequency"
  #   unit_of_measurement: "Hz"
  #   accuracy_decimals: 1
  #   state: "VB11"
  #   state_number:
  #     offset: 4
  #     length: $float_length 
  #     decode: "ascii"

  - platform: uartex
    id: vb_ac_inverter_power
    name: "AC Inverter Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 1
    state: "VB12"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vb_inverter_state
    name: "Inverter State"
    accuracy_decimals: 0
    state: "VB13"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        # Use template sensors to decode status locally and reduce number of uartex sensors reqd 
        - binary_sensor.template.publish:
            id: vc_multi_mains
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x01) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_absorb
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x02) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_bulk
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x04) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_float
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x08) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_inverter
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x10) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_overload
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x20) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_lowbatt
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x40) > 0 ? true : false;' 
        - binary_sensor.template.publish:
            id: vc_multi_temp
            state: !lambda 'return ((int)id(vb_inverter_state).state & 0x80) > 0 ? true : false;' 

  - platform: uartex
    id: ve_bmv_soc
    name: "Battery SOC"
    device_class: "battery"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VE01"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bmv_soc
            text:
              format: "SOC: %.1f%%"
              args: [ 'id(ve_bmv_soc).state' ]

  - platform: uartex
    id: ve_bmv_voltage
    name: "Battery Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE02"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bmv_voltage
            text:
              format: "Main Volt: %.2fV"
              args: [ 'id(ve_bmv_voltage).state' ]

  - platform: uartex
    id: ve_bmv_startv
    name: "Starter Voltage"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE03"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bmv_startv
            text:
              format: "Start Volt: %.2fV"
              args: [ 'id(ve_bmv_startv).state' ]

  - platform: uartex
    id: ve_bmv_power
    name: "Battery Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    state: "VE04"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bmv_power
            text:
              format: "Power: %.1fW"
              args: [ 'id(ve_bmv_power).state' ]

  - platform: uartex
    id: ve_bmv_current
    name: "Battery Current"
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 2
    state: "VE05"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bmv_current
            text:
              format: "Current: %.2fA"
              args: [ 'id(ve_bmv_current).state' ]

  - platform: uartex
    id: ve_bmv_alarm
    name: "Battery Alarm"
    unit_of_measurement: "units"
    accuracy_decimals: 0
    state: "VE06"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bmv_alarm
            text:
              format: "Alarm: %.0f"
              args: [ 'id(ve_bmv_alarm).state' ]

  # - platform: uartex
  #   id: ve_bmv_relay
  #   name: "Battery Relay"
  #   unit_of_measurement: "units"
  #   accuracy_decimals: 0
  #   state: "VE07"
  #   state_number:
  #     offset: 4
  #     length: $float_length 
  #     decode: "ascii"

  - platform: uartex
    id: ve_mppt_voltage
    name: "MPPT V"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE08"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_mppt_voltage
            text:
              format: "MPPT V: %.2fV"
              args: [ 'id(ve_mppt_voltage).state' ]

  - platform: uartex
    id: ve_mppt_panel_voltage
    name: "Solar V"
    device_class: "voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state: "VE09"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_mppt_panel_voltage
            text:
              format: "Solar V: %.2fV"
              args: [ 'id(ve_mppt_panel_voltage).state' ]

  - platform: uartex
    id: ve_mppt_power
    name: "Solar Power"
    device_class: "power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    state: "VE10"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_mppt_power
            text:
              format: "MPPT Pwr: %.1fW"
              args: [ 'id(ve_mppt_power).state' ]

  - platform: uartex
    id: ve_mppt_current
    name: "Solar Current"
    device_class: "current"
    unit_of_measurement: "A"
    accuracy_decimals: 2
    state: "VE11"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_mppt_current
            text:
              format: "MPPT I: %.2fA"
              args: [ 'id(ve_mppt_current).state' ]

  - platform: uartex
    id: ve_mppt_state
    name: "MPTT State"
    accuracy_decimals: 0
    state: "VE13"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        # Use template sensors to decode status locally and reduce number of uartex sensors reqd 
        - binary_sensor.template.publish:
            id: ve_mppt_fault
            state: !lambda 'return ((int)id(ve_mppt_state).state  == 2) ? true : false;' 
        - binary_sensor.template.publish:
            id: ve_mppt_bulk
            state: !lambda 'return ((int)id(ve_mppt_state).state  == 3) ? true : false;' 
        - binary_sensor.template.publish:
            id: ve_mppt_absorption
            state: !lambda 'return ((int)id(ve_mppt_state).state  == 4) ? true : false;' 
        - binary_sensor.template.publish:
            id: ve_mppt_float
            state: !lambda 'return ((int)id(ve_mppt_state).state  == 5) ? true : false;' 
        - binary_sensor.template.publish:
            id: ve_mppt_starting
            state: !lambda 'return ((int)id(ve_mppt_state).state  == 245) ? true : false;' 

  - platform: uartex
    id: vt_light_lux
    name: "Light Lux"
    unit_of_measurement: "lx"
    accuracy_decimals: 0
    state: "VT01"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_light_lux
            text:
              format: "Light: %.0flx"
              args: [ 'id(vt_light_lux).state' ]

  - platform: uartex
    id: vt_engine_rpm
    name: "Engine RPM"
    unit_of_measurement: "rpm"
    accuracy_decimals: 0
    state: "VT02"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_dht1_temp
    name: "Lounge Temp"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT03"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_lounge_temp
            text:
              format: "Lounge: %.1f°C"
              args: [ 'id(vt_dht1_temp).state' ]
        - lvgl.bar.update:
            id: bar_lounge_temp
            value: !lambda 'return (id(vt_dht1_temp).state) * $temp_bar_scale;'

  - platform: uartex
    id: vt_dht1_humidity
    name: "Lounge Humidity"
    device_class: "humidity"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VT04"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value: 
      then:
        - lvgl.label.update:
            id: lbl_lounge_humidity
            text:
              format: "%.0f%%"
              args: [ 'id(vt_dht1_humidity).state' ]
        - lvgl.bar.update:  
            id: bar_lounge_humidity
            value: !lambda 'return id(vt_dht1_humidity).state;'

  - platform: uartex
    id: vt_dht2_temp
    name: "Dining Temp"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT05"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_dining_temp
            text:
              format: "Dining: %.1f°C"
              args: [ 'id(vt_dht2_temp).state' ]
        - lvgl.bar.update:
            id: bar_dining_temp
            value: !lambda 'return (id(vt_dht2_temp).state) * $temp_bar_scale;'

  - platform: uartex
    id: vt_dht2_humidity
    name: "Dining Humidity"
    device_class: "humidity"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VT06"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value: 
      then:
        - lvgl.label.update:
            id: lbl_dining_humidity
            text:
              format: "%.0f%%"
              args: [ 'id(vt_dht2_humidity).state' ]
        - lvgl.bar.update:  
            id: bar_dining_humidity
            value: !lambda 'return id(vt_dht2_humidity).state;'

  - platform: uartex
    id: vt_dht3_temp
    name: "Bedroom Temp"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT07"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bedroom_temp
            text:
              format: "Bedroom: %.1f°C"
              args: [ 'id(vt_dht3_temp).state' ]
        - lvgl.bar.update:
            id: bar_bedroom_temp
            value: !lambda 'return (id(vt_dht3_temp).state) * $temp_bar_scale;'

  - platform: uartex
    id: vt_dht3_humidity
    name: "Bedroom Humidity"
    device_class: "humidity"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VT08"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value: 
      then:
        - lvgl.label.update:
            id: lbl_bedroom_humidity
            text:
              format: "%.0f%%"
              args: [ 'id(vt_dht3_humidity).state' ]
        - lvgl.bar.update:  
            id: bar_bedroom_humidity
            value: !lambda 'return id(vt_dht3_humidity).state;'

  - platform: uartex
    id: vt_dht4_temp
    name: "Cupboard Temp"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT09"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_cupboard_temp
            text:
              format: "Cupboard: %.1f°C"
              args: [ 'id(vt_dht4_temp).state' ]
        - lvgl.bar.update:
            id: bar_cupboard_temp
            value: !lambda 'return (id(vt_dht4_temp).state) * $temp_bar_scale;'

  - platform: uartex
    id: vt_dht4_humidity
    name: "Cupboard Humidity"
    device_class: "humidity"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VT10"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value: 
      then:
        - lvgl.label.update:
            id: lbl_cupboard_humidity
            text:
              format: "%.0f%%"
              args: [ 'id(vt_dht4_humidity).state' ]
        - lvgl.bar.update:  
            id: bar_cupboard_humidity
            value: !lambda 'return id(vt_dht4_humidity).state;'

  - platform: uartex
    id: vt_dht5_temp
    name: "Bathroom Temp"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT11"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value:
      then:
        - lvgl.label.update:
            id: lbl_bathroom_temp
            text:
              format: "Bathroom: %.1f°C"
              args: [ 'id(vt_dht5_temp).state' ]
        - lvgl.bar.update:
            id: bar_bathroom_temp
            value: !lambda 'return (id(vt_dht5_temp).state) * $temp_bar_scale;'

  - platform: uartex
    id: vt_dht5_humidity
    name: "Bathroom Humidity"
    device_class: "humidity"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state: "VT12"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
    on_value: 
      then:
        - lvgl.label.update:
            id: lbl_bathroom_humidity
            text:
              format: "%.0f%%"
              args: [ 'id(vt_dht5_humidity).state' ]
        - lvgl.bar.update:  
            id: bar_bathroom_humidity
            value: !lambda 'return id(vt_dht5_humidity).state;'

  - platform: uartex
    id: vt_temp1
    name: "Water Cyl Top"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT13"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
  
  - platform: uartex
    id: vt_temp2
    name: "Water Cyl Bottom"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT14"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"
  
  - platform: uartex
    id: vt_temp3
    name: "Eberspacher Flow"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT15"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp4
    name: "Eberspacher Return"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT16"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp5
    name: "Engine Flow"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT17"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp6
    name: "Engine Return"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT18"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp7
    name: "Skin Tank Flow"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT19"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp8
    name: "Skin Tank Return"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT20"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp9
    name: "Gearbox"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT21"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp10
    name: "Propshaft"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT22"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp11
    name: "Battery Temp"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT23"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp12
    name: "Main Alternator"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT24"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"

  - platform: uartex
    id: vt_temp13
    name: "Aux Alternator"
    device_class: "temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state: "VT25"
    state_number:
      offset: 4
      length: $float_length 
      decode: "ascii"


text_sensor:
  - platform: uartex
    id: atmega_diagnostic
    name: "ATMega Diag"
    entity_category: "diagnostic"
    state: "T1"
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars
  - platform: uartex
    id: atmega_info
    name: "ATMega Info"
    entity_category: "diagnostic"
    state: "T2"
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars

binary_sensor:
  - platform: uartex
    id: atmega_button
    name: "ATMega Button"
    state: "B1"
    state_on:
      offset: 2
      data: [0x31] # ASCII '1'
    state_off:
      offset: 2
      data: [0x30] # ASCII '0'
    on_state:
      then:
        - lvgl.label.update:
            id: lbl_app_name #lbl_button_state
            text:
              format: "Button State:\n%s"
              args: [ 'id(atmega_button).state ? "Pressed" : "Released"' ]

# A bunch of template sensors to decode status in this device and reduce the uartex sensors required
  - platform: template
    id: vc_multi_mains
    name: "Multi Mains"

  - platform: template
    id: vc_multi_absorb
    name: "Multi Absorb"

  - platform: template
    id: vc_multi_bulk
    name: "Multi Bulk"

  - platform: template
    id: vc_multi_float
    name: "Multi Float"

  - platform: template
    id: vc_multi_inverter
    name: "Multi Inverter"

  - platform: template
    id: vc_multi_overload
    name: "Multi Overload"

  - platform: template
    id: vc_multi_lowbatt
    name: "Multi Low Battery"

  - platform: template
    id: vc_multi_temp
    name: "Multi Temperature"

  - platform: template
    id: ve_mppt_fault
    name: "MPPT Fault"

  - platform: template
    id: ve_mppt_bulk
    name: "MPPT Bulk"

  - platform: template
    id: ve_mppt_absorption
    name: "MPPT Absorp"

  - platform: template
    id: ve_mppt_float
    name: "MPPT Float"

  - platform: template
    id: ve_mppt_starting
    name: "MPPT Start"

