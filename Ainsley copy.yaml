substitutions:
  devicename: ainsleymonitor
  tx_pin: GPIO1
  rx_pin: GPIO3
  led_pin: GPIO14
  button_pin: GPIO13
  sensor_update: 60s

esphome:
  name: $devicename

esp8266:
  board: esp07s #esp01_1m #d1_mini_pro

uart:
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1
  tx_pin: $tx_pin
  rx_pin: $rx_pin

external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 100ms
  tx_delay: 50ms
  tx_timeout: 500ms
  tx_retry_cnt: 3

  # rx_header: [0x02, 0x01]
  rx_footer: [0x0D, 0x0A]
  # tx_header: [0x02, 0x01]
  tx_footer: [0x0D, 0x0A]

  version:
    disabled: False
  error:
    disabled: False
  log:
    disabled: True #False

sensor:
  - platform: template
    id: num_from_text
    name: "Number from text"
    unit_of_measurement: "units"
    accuracy_decimals: 2

  - platform: uartex
    id: test_sensor_1
    name: "Test Sensor 1"
    unit_of_measurement: "units"
    state: "V1"
    state_number:
      offset: 2
      length: 6 #If value received is shorter than this, decoding seems OK
      precision: 2
      decode: "ascii"
    accuracy_decimals: 2

  - platform: uartex #Working example for integer ascii values
    id: test_sensor_2
    name: "Test Sensor 2"
    unit_of_measurement: "units"
    state: "V2"
    state_number:
      offset: 2
      length: 4
      precision: 0
      decode: "ascii"

  - platform: uartex
    id: test_sensor_3
    name: "Test Sensor 3"
    unit_of_measurement: "units"
    accuracy_decimals: 2
    state: "V3"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+2), len-2).c_str());
      return n.has_value() ? n.value() : NAN;


  - platform: uartex
    id: test_sensor_4
    name: "Test Sensor 4"
    unit_of_measurement: "units"
    accuracy_decimals: 3
    state: "V4"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+2), len-2));
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: test_sensor_5
    name: "Test Sensor 5"
    unit_of_measurement: "units"
    accuracy_decimals: 3
    state: "V5"
    lambda: |-
      std::string str =  std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply 

      auto n = parse_number<float>(str);
      return n.has_value() ? n.value() : NAN;

  - platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
    icon: mdi:wifi
    name: "WiFi Signal dB"
    id: wifi_signal_db
    unit_of_measurement: "dB"
    update_interval: ${sensor_update}
    entity_category: "diagnostic"
                
  - platform: uptime
    name: "Uptime"


text_sensor:
  - platform: uartex
    id: test_text_sensor
    name: "Test Text Sensor"
    state: "T1"
    lambda: |-
      // return std::string(reinterpret_cast<const char*>(data), len); // Simply return the received string
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars
    on_value:
      then:
        - sensor.template.publish:
            id: num_from_text
            state: !lambda |-
              auto n = parse_number<float>(x);
              return n.has_value() ? n.value() : NAN;
  - platform: wifi_info
    ssid:
      icon: mdi:wifi
      id: wifi_ssid
      name: "WiFi SSID"
    dns_address:
      icon: mdi:wifi
      id: wifi_dns
      name: "WiFi DNS"
    ip_address:
      icon: mdi:wifi
      id: wifi_ip
      name: "WiFi IP"

wifi:
  networks:
    - ssid: !secret wifi_comp_ssid
      password: !secret wifi_comp_password
    - ssid: !secret wifi_home_ssid
      password: !secret wifi_home_password
    - ssid: !secret wifi_phone_ssid
      password: !secret wifi_phone_password
    - ssid: !secret wifi_bshed_ssid
      password: !secret wifi_bshed_password
  on_connect:
    - uart.write: "\n\nESP8266 Reboot, WiFi connected\r\n"
    
interval:
  - interval: $sensor_update
    then: #publish wifi info every sensor_update interval as it is not valid when WiFi first starts up
      - mqtt.publish:
          topic: $devicename/sensor/wifi_ssid/state
          payload: !lambda |-
            return id(wifi_ssid).state;
      - mqtt.publish:
          topic: $devicename/sensor/wifi_dns/state
          payload: !lambda |-
            return id(wifi_dns).state;
      - mqtt.publish:
          topic: $devicename/sensor/wifi_ip/state
          payload: !lambda |-
            return id(wifi_ip).state;

mqtt:
  broker: allsmiths.synology.me
  port: 1883
  username: !secret mqtt_username
  password: !secret mqtt_password
  #no clientid reqd
  discovery: true # disable entity discovery
  discover_ip: true # enable device discovery
  discovery_retain: true #retain discovery messages
  discovery_unique_id_generator: mac #Use Mac address to generate unique entity Ids

ota:
  platform: esphome

logger:
  baud_rate: 0 # disable uart logging (MQTT logging still happens) as we need to retain the serial port free for comms with AT Mega
  level: DEBUG

button: 
  - platform: restart #virtual button to remotely reboot device
    id: restart_button
    name: Restart

binary_sensor:
  - platform: gpio
    pin: 
      number: $button_pin
      inverted: True
    name: "ESP8266 Button"

light:
  - platform: status_led
    name: "ESP8266 LED"
    id: devicename_led
    pin: 
      number: $led_pin
      inverted: False
    restore_mode: RESTORE_DEFAULT_OFF
