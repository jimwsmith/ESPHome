# Specific code for the Home Assistant Boat Monitor unit that just mirrors the main unit goes in here
# Uses some dummy template MQTT sensors to receive the published info from main unit.
# Tricky part was the relay controls which also now publish as though they were main unit if teh buttons are pressed in lvgl screen

esphome:
  name: ${esphome_name}

number:
  - platform: template
    disabled_by_default: True #Hide device in Home Assistant as this just receives values set on main unit
    command_topic: ${esphome_source}/number/soc_warning_level/command #Monitor state of another device
    id: soc_warn_level
    name: "SOC warning level"
    max_value: 100
    min_value: 0
    step: 1
    optimistic: true  
    initial_value: 85
    restore_value: true
    on_value: 
      then:
        - script.execute: soc_check_alarm
  - platform: template
    disabled_by_default: True #Hide device in Home Assistant
    command_topic: ${esphome_source}/number/soc_alarm_level/command #Monitor state of another device
    id: soc_alarm_level
    name: "SOC alarm level"
    max_value: 100
    min_value: 0
    step: 1
    optimistic: true  
    initial_value: 70
    restore_value: true
    on_value: 
      then:
        - script.execute: soc_check_alarm

text_sensor:
# Receive messages from Boat relay switches (including retained state) and use to update this unit's relay switches as a mirror
  - platform: mqtt_subscribe
    name: "relay 1 sender"
    id: relay_1_sender
    topic: ${esphome_source}/switch/atmega_relay_1/state   
    on_value:
    # #debug code remove later
    #   - logger.log:
    #       format: "received State from Boat Relay 1 %s"
    #       args: [ 'id(relay_1_sender).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_1_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_1
      - if:
          condition:
            lambda: 'return (id(relay_1_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_1
  - platform: mqtt_subscribe
    name: "relay 2 sender"
    id: relay_2_sender
    topic: ${esphome_source}/switch/atmega_relay_2/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 2 %s"
      #     args: [ 'id(relay_2_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_2_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_2
      - if:
          condition:
            lambda: 'return (id(relay_2_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_2
  - platform: mqtt_subscribe
    name: "relay 3 sender"
    id: relay_3_sender
    topic: ${esphome_source}/switch/atmega_relay_3/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 3 %s"
      #     args: [ 'id(relay_3_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_3_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_3
      - if:
          condition:
            lambda: 'return (id(relay_3_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_3
  - platform: mqtt_subscribe
    name: "relay 4 sender"
    id: relay_4_sender
    topic: ${esphome_source}/switch/atmega_relay_4/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 4 %s"
      #     args: [ 'id(relay_4_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_4_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_4
      - if:
          condition:
            lambda: 'return (id(relay_4_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_4
  - platform: mqtt_subscribe
    name: "relay 5 sender"
    id: relay_5_sender
    topic: ${esphome_source}/switch/atmega_relay_5/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 5 %s"
      #     args: [ 'id(relay_5_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_5_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_5
      - if:
          condition:
            lambda: 'return (id(relay_5_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_5
  - platform: mqtt_subscribe
    name: "relay 6 sender"
    id: relay_6_sender
    topic: ${esphome_source}/switch/atmega_relay_6/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 6 %s"
      #     args: [ 'id(relay_6_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_6_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_6
      - if:
          condition:
            lambda: 'return (id(relay_6_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_6

# Same code as main unit really but adds a MQTT publish simulating main unit if buttons checked on lvgl screen
switch: 
  - platform: template
    id: relay_1
    name: "ATMega Relay 1"
    turn_on_action:
      - uart.write: [0x52, 0x31, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_1
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_1/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x31, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_1
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_1/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_2
    name: "ATMega Relay 2"
    turn_on_action:
      - uart.write: [0x52, 0x32, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_2
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_2/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x32, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_2
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_2/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_3
    name: "ATMega Relay 3"
    turn_on_action:
      - uart.write: [0x52, 0x33, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_3
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_3/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x33, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_3
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_3/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_4
    name: "ATMega Relay 4"
    turn_on_action:
      - uart.write: [0x52, 0x34, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_4
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_4/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x34, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_4
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_4/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_5
    name: "ATMega Relay 5"
    turn_on_action:
      - uart.write: [0x52, 0x35, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_5
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_5/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x35, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_5
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_5/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_6
    name: "ATMega Relay 6"
    turn_on_action:
      - uart.write: [0x52, 0x36, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_6
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_6/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x36, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_6
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_6/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

# Don't want a conflicting climate control here - only use main Boat device
