# Specific code for the Home Assistant Boat Monitor unit that just mirrors the main unit goes in here
# Uses some dummy template MQTT sensors to receive the published info from main unit.
# Tricky part was the relay controls which also now publish as though they were main unit if teh buttons are pressed in lvgl screen

esphome:
  name: ${esphome_name}

number:
  - platform: template
    disabled_by_default: True #Hide device in Home Assistant as this just receives values set on main unit
    command_topic: ${esphome_source}/number/soc_warning_level/command #Monitor state of another device
    id: soc_warn_level
    name: "SOC warning level"
    max_value: 100
    min_value: 0
    step: 1
    optimistic: true  
    initial_value: 85
    restore_value: true
    on_value: 
      then:
        - script.execute: soc_check_alarm
  - platform: template
    disabled_by_default: True #Hide device in Home Assistant
    command_topic: ${esphome_source}/number/soc_alarm_level/command #Monitor state of another device
    id: soc_alarm_level
    name: "SOC alarm level"
    max_value: 100
    min_value: 0
    step: 1
    optimistic: true  
    initial_value: 70
    restore_value: true
    on_value: 
      then:
        - script.execute: soc_check_alarm

#Only fit GPS unit to the receiver Fire unit
gps:
  latitude:
    id: gps_latitude
    name: "Latitude"
  longitude:
    id: gps_longitude
    name: "Longitude"
  altitude:
    id: gps_altitude
    name: "Altitude"
    filters: #Altitude is very noisy signal so average it out
      - sliding_window_moving_average:
          window_size: 10
          send_every: 10
  speed:
    id: gps_speed_kmh
    name: "Speed"
  course:
    id: gps_course
    name: "Course"
  satellites:
    id: pgs_satelites
    name: "Satellites"
  hdop:
    id: gps_hdop
    name: "HDOP"
    device_class: distance
    unit_of_measurement: "m"
  update_interval: ${update_interval_speed}
  uart_id: uart_bus
# Note in HA these are combined into a position sensor using a template sensor with multiple attributes

sensor:
  - platform: template
    name: "Speed mph"
    id: speed_mph
    unit_of_measurement: "mph"
    device_class: speed
    accuracy_decimals: 1
    update_interval: ${update_interval_speed}
    lambda: |-
      if (id(gps_speed_kmh).state < 0.4) return 0; //Ignore low speeds as these are just noise
      return id(gps_speed_kmh).state * 0.621371;
    on_value:
      then:
        - lvgl.indicator.update:
            id: speed_needle
            value: !lambda 'return (id(speed_mph).state)*100; //Scale value as meter only copes with integers' 
        - lvgl.label.update:
            id: lbl_speed_dial
            text:
              format: "%.1f"
              args: [ 'id(speed_mph).state' ]


text_sensor:
# Receive messages from Boat relay switches (including retained state) and use to update this unit's relay switches as a mirror
  - platform: mqtt_subscribe
    name: "relay 1 sender"
    id: relay_1_sender
    topic: ${esphome_source}/switch/atmega_relay_1/state   
    on_value:
    # #debug code remove later
    #   - logger.log:
    #       format: "received State from Boat Relay 1 %s"
    #       args: [ 'id(relay_1_sender).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_1_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_1
      - if:
          condition:
            lambda: 'return (id(relay_1_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_1
  - platform: mqtt_subscribe
    name: "relay 2 sender"
    id: relay_2_sender
    topic: ${esphome_source}/switch/atmega_relay_2/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 2 %s"
      #     args: [ 'id(relay_2_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_2_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_2
      - if:
          condition:
            lambda: 'return (id(relay_2_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_2
  - platform: mqtt_subscribe
    name: "relay 3 sender"
    id: relay_3_sender
    topic: ${esphome_source}/switch/atmega_relay_3/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 3 %s"
      #     args: [ 'id(relay_3_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_3_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_3
      - if:
          condition:
            lambda: 'return (id(relay_3_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_3
  - platform: mqtt_subscribe
    name: "relay 4 sender"
    id: relay_4_sender
    topic: ${esphome_source}/switch/atmega_relay_4/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 4 %s"
      #     args: [ 'id(relay_4_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_4_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_4
      - if:
          condition:
            lambda: 'return (id(relay_4_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_4
  - platform: mqtt_subscribe
    name: "relay 5 sender"
    id: relay_5_sender
    topic: ${esphome_source}/switch/atmega_relay_5/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 5 %s"
      #     args: [ 'id(relay_5_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_5_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_5
      - if:
          condition:
            lambda: 'return (id(relay_5_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_5
  - platform: mqtt_subscribe
    name: "relay 6 sender"
    id: relay_6_sender
    topic: ${esphome_source}/switch/atmega_relay_6/state   
    on_value:
      # - logger.log:
      #     format: "State from Boat Relay 6 %s"
      #     args: [ 'id(relay_6_state).state.c_str()' ]
      - if:
          condition:
            lambda: 'return (id(relay_6_sender).state == "ON");'
          then:
            - switch.turn_on:
                  id: relay_6
      - if:
          condition:
            lambda: 'return (id(relay_6_sender).state == "OFF");'
          then:
            - switch.turn_off:
                  id: relay_6

# Same code as main unit really but adds a MQTT publish simulating main unit if buttons checked on lvgl screen
switch: 
  - platform: template
    id: relay_1
    name: "ATMega Relay 1"
    turn_on_action:
      - uart.write: [0x52, 0x31, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_1
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_1/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x31, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_1
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_1/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_2
    name: "ATMega Relay 2"
    turn_on_action:
      - uart.write: [0x52, 0x32, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_2
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_2/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x32, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_2
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_2/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_3
    name: "ATMega Relay 3"
    turn_on_action:
      - uart.write: [0x52, 0x33, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_3
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_3/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x33, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_3
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_3/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_4
    name: "ATMega Relay 4"
    turn_on_action:
      - uart.write: [0x52, 0x34, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_4
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_4/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x34, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_4
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_4/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_5
    name: "ATMega Relay 5"
    turn_on_action:
      - uart.write: [0x52, 0x35, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_5
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_5/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x35, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_5
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_5/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_6
    name: "ATMega Relay 6"
    turn_on_action:
      - uart.write: [0x52, 0x36, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_6
          state:
            checked: True
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_6/command
          payload: "ON"      
    turn_off_action:
      - uart.write: [0x52, 0x36, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_6
          state:
            checked: False
      - mqtt.publish:
          topic: ${esphome_source}/switch/atmega_relay_6/command
          payload: "OFF"      
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

# Don't want a conflicting climate control here - only use main Boat device
