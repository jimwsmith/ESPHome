substitutions:
  friendly_name: "Fire7" #Fireboat2 duplicate
  esphome_name: "fire7"
  sensor_update: 60s
  float_length : "10"
  temp_bar_scale: "3.0" #Scale factor to convert room temperature to 0-100 range for lvgl bar display

  tx_pin: GPIO26 #TXD2 M5Stack Fire
  rx_pin: GPIO36 #GPIO36 #RXD2 on M5Stack Fire
  led_strbuf_size: "16"

esphome:
  name: ${esphome_name}
  friendly_name: ${friendly_name}
  on_boot:
    - priority: 600 #Uart should be configured before this runs
      then:
        - uart.write: "\r\n" #clear out any partial data sent as Uart started so that LED setup string will be interpreted OK
    - priority: -100 #Ensure this runs after lvgl is initialised
      then:
        - delay: 8s
        - lvgl.widget.hide: boot_screen
        - uart.write: "\r\n" #clear out any partial data sent as Uart started
        - uart.write: "Info\r\n" #Requesting version info from AT Mega on boot"

packages:
  m5stackfire: !include M5StackFire.yaml
  wifi: !include wifi.yaml
  mqtt: !include mqttboat.yaml
  lvgl: !include lvglboat.yaml
  uart: !include FireUartex.yaml

uart:
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1
  tx_pin: $tx_pin
  rx_pin: $rx_pin
  rx_buffer_size: 512

external_components:
  - source:
      type: git
      url: https://github.com/ssieb/custom_components

# Enable logging
logger:
  logs:
    component: DEBUG #Supress excessive warnings about display writing
  
# captive_portal:

number:
  - platform: template
    id: wifi_error_count
    name: "WiFi Error Count"
    unit_of_measurement: "errors"
    entity_category: "diagnostic"
    max_value: 1000000
    min_value: 0  
    step: 1
    optimistic: true  
  - platform: template
    id: mqtt_error_count
    name: "MQTT Error Count"
    entity_category: "diagnostic"
    unit_of_measurement: "errors"
    max_value: 1000000
    min_value: 0  
    step: 1
    optimistic: true  

time:
  - platform: sntp 
    id: sntp_time
    on_time: #Automation to enable display screen saver
      # - hours: 2,3,4,5
      #   minutes: 5
      #   seconds: 30
      #   then:
      #     - switch.turn_on: switch_antiburn
      # - hours: 2,3,4,5
      #   minutes: 35
      #   seconds: 30
      #   then:
      #     - switch.turn_off: switch_antiburn
      - minutes: '*'
        seconds: 0
        then:
          - script.execute: time_update #Updates time in top_level lvgl display
    on_time_sync:
      - script.execute: time_update

script:
  - id: time_update
    then:
      - lvgl.label.update:
          id: lbl_time
          text: 
            format: "%s"
            args: [ 'id(sntp_time).now().strftime("%R").c_str()' ]

debug:
  update_interval: 5s

text_sensor:
  - platform: debug
    device:
      name: "Device Info"
    reset_reason:
      name: "Reset Reason"

# Enable this sensor to track memory leak issues
# sensor:
#   - platform: debug
#     free:
#       name: "Heap Free"
#     loop_time:
#       name: "Loop Time"
#     psram:
#       name: "Free PSRAM"

light:
  - platform: rgb #Individual control of RGB elemenst of LED strip driven from AT Mega via this unit
    name: "ATMega RGB Light"
    id: ainsley_rgb_light
    red: output_red
    green: output_green
    blue: output_blue
    default_transition_length: 0s #instant change of colour as we cannot cope with transitions
    restore_mode: RESTORE_DEFAULT_OFF

output:
# Consider adding \r\n at start of each command if issues arise with LED control
  - platform: template
    id: output_red
    type: float
    write_action:
      - logger.log:
          format: "Setting RED output to %.2f"
          args: [ 'state' ]
      - uart.write: !lambda  |-
          char buf[$led_strbuf_size];
          snprintf(buf, $led_strbuf_size, "LR%02X\r\n", (int)(255*state)); //Send colour value to AT Mega
          std::string s = buf;
          return std::vector<unsigned char>( s.begin(), s.end() );
  - platform: template
    id: output_green
    type: float
    write_action:
      - uart.write: !lambda  |-
          char buf[$led_strbuf_size];
          snprintf(buf, $led_strbuf_size, "LG%02X\r\n", (int)(255*state)); //Send colour value to AT Mega
          std::string s = buf;
          return std::vector<unsigned char>( s.begin(), s.end() );
  - platform: template
    id: output_blue
    type: float
    write_action:
      - uart.write: !lambda  |-
          char buf[$led_strbuf_size];
          snprintf(buf, $led_strbuf_size, "LB%02X\r\n", (int)(255*state)); //Send colour value to AT Mega
          std::string s = buf;
          return std::vector<unsigned char>( s.begin(), s.end() );

switch: 
  - platform: template
    id: relay_1
    name: "ATMega Relay 1"
    turn_on_action:
      - uart.write: [0x52, 0x31, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_1
          state:
            checked: True
    turn_off_action:
      - uart.write: [0x52, 0x31, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_1
          state:
            checked: False
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_2
    name: "ATMega Relay 2"
    turn_on_action:
      - uart.write: [0x52, 0x32, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_2
          state:
            checked: True
    turn_off_action:
      - uart.write: [0x52, 0x32, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_2
          state:
            checked: False
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_3
    name: "ATMega Relay 3"
    turn_on_action:
      - uart.write: [0x52, 0x33, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_3
          state:
            checked: True
    turn_off_action:
      - uart.write: [0x52, 0x33, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_3
          state:
            checked: False
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_4
    name: "ATMega Relay 4"
    turn_on_action:
      - uart.write: [0x52, 0x34, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_4
          state:
            checked: True
    turn_off_action:
      - uart.write: [0x52, 0x34, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_4
          state:
            checked: False
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_5
    name: "ATMega Relay 5"
    turn_on_action:
      - uart.write: [0x52, 0x35, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_5
          state:
            checked: True
    turn_off_action:
      - uart.write: [0x52, 0x35, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_5
          state:
            checked: False
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change

  - platform: template
    id: relay_6
    name: "ATMega Relay 6"
    turn_on_action:
      - uart.write: [0x52, 0x36, 0x31, 0x0A, 0x0D] #Send Relay state to AT Mega R21\r\n
      - lvgl.widget.update:
          id: btn_relay_6
          state:
            checked: True
    turn_off_action:
      - uart.write: [0x52, 0x36, 0x30, 0x0A, 0x0D] #Send Relay state to AT Mega R20\r\n
      - lvgl.widget.update:
          id: btn_relay_6
          state:
            checked: False
    optimistic: true #Required so that state change gets registered even though there is no actual comms back to ack the relay change
