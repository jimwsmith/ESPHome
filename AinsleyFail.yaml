substitutions:
  devicename: boat
  # led_pin: GPIO14 #ATMega with ESP8266
  # button_pin: GPIO13
  # tx_pin: GPIO1
  # rx_pin: GPIO3
  led_pin: GPIO2 #D1 Mini Pro ESP8266 note LED is inverted logic
  button_pin: GPIO0
  tx_pin: GPIO15
  rx_pin: GPIO13
  sensor_update: 60s
  led_strbuf_size: "16"

esphome:
  name: $devicename

esp8266:
  # board: esp07s #d1_mini_pro
  # board: d1_mini_pro
  board: nodemcuv2 #Actualy Node MCUV3

logger:
  # baud_rate: 0 # disable uart logging (MQTT logging still happens) as we need to retain the serial port free for comms with AT Mega
  level: DEBUG

uart:
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1
  tx_pin: $tx_pin
  rx_pin: $rx_pin
  rx_buffer_size: 512

wifi:
  networks:
    - ssid: !secret wifi_home_ssid
      password: !secret wifi_home_password
    
mqtt:
  broker: !secret mqtt_broker
  port: 1883
  username: !secret mqtt_username
  password: !secret mqtt_password
  #no clientid reqd
  discovery: true # disable entity discovery
  discover_ip: true # enable device discovery
  discovery_retain: true #retain discovery messages
  discovery_unique_id_generator: mac #Use Mac address to generate unique entity Ids

ota:
  platform: esphome

light:
  - platform: status_led #Built in LED to show status for SP8266
    name: "ESP8266 LED"
    id: devicename_led
    pin: 
      number: $led_pin
      # inverted: False #AT Mega with ESP8266
      inverted: True #D1 Mini Pro ESP8266
    restore_mode: RESTORE_DEFAULT_ON

binary_sensor:
  - platform: gpio
    pin: 
      number: $button_pin
      inverted: True
    name: "ESP8266 Button"


external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 10ms
  tx_delay: 50ms
  tx_timeout: 500ms
  tx_retry_cnt: 3
  rx_priority: loop #Lower priority for Rx than main loop tasks
  # rx_header: [0x02, 0x01]
  rx_footer: [0x0D, 0x0A]
  # tx_header: [0x02, 0x01]
  tx_footer: [0x0D, 0x0A]

  version:
    name: "Uartex Version"
    disabled: False
  error:
    name: "Uartex Error"
    disabled: False
  log:
    name: "Uartex Log"
    disabled: True #False

sensor: 
  - platform: uartex
    name: "Sensor 1"
    state: "XX01"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 2"
    state: "XX02"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 3"
    state: "XX03"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 4"
    state: "XX04"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 5"
    state: "XX05"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 6"
    state: "XX06"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 7"
    state: "XX07"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 8"
    state: "XX08"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 9"
    state: "XX09"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 10"
    state: "XX10"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 11"
    state: "XX11"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 12"
    state: "XX12"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 13"
    state: "XX13"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 14"
    state: "XX14"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    name: "Sensor 15"
    state: "XX15"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+4), len-4).c_str());
      return n.has_value() ? n.value() : NAN;
