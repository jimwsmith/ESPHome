
external_components:
  - source: github://eigger/espcomponents@latest
    components: [ uartex ]
    refresh: always

uartex:
  rx_timeout: 10ms
  tx_delay: 50ms
  tx_timeout: 500ms
  tx_retry_cnt: 3
  rx_priority: loop #Lower priority for Rx than main loop tasks
  # rx_header: [0x02, 0x01]
  rx_footer: [0x0D, 0x0A]
  # tx_header: [0x02, 0x01]
  tx_footer: [0x0D, 0x0A]

  version:
    name: "Uartex Version"
    disabled: False
  error:
    name: "Uartex Error"
    disabled: False
  log:
    name: "Uartex Log"
    disabled: True #False

sensor: 
  - platform: uartex
    id: Mega_uptime_sensor
    name: "Mega Uptime"
    unit_of_measurement: "m"
    state: "H1"
    state_number:
      offset: 2
      length: 16 #If value received is shorter than this, decoding seems OK
      precision: 0
      decode: "ascii"
    accuracy_decimals: 0

  - platform: uartex
    id: atmega_button_counter
    name: "ATMega Button Counter"
    unit_of_measurement: "units"
    state: "B2"
    state_number:
      offset: 2
      length: 16 #If value received is shorter than this, decoding seems OK
      precision: 0
      decode: "ascii"
    accuracy_decimals: 0

  - platform: uartex #Working example for integer ascii values
    id: test_sensor_2
    name: "Test Sensor 2"
    unit_of_measurement: "units"
    state: "V2"
    state_number:
      offset: 2
      length: 16
      precision: 0
      decode: "ascii"

  - platform: uartex
    id: test_sensor_3
    name: "Test Sensor 3"
    unit_of_measurement: "units"
    accuracy_decimals: 2
    state: "V3"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+2), len-2).c_str());
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: test_sensor_4
    name: "Test Sensor 4"
    unit_of_measurement: "units"
    accuracy_decimals: 3
    state: "V4"
    lambda: |-
      auto n = parse_number<float>(std::string(reinterpret_cast<const char*>(data+2), len-2));
      return n.has_value() ? n.value() : NAN;

  - platform: uartex
    id: test_sensor_5
    name: "Test Sensor 5"
    unit_of_measurement: "units"
    accuracy_decimals: 3
    state: "V5"
    lambda: |-
      std::string str =  std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply 
      auto n = parse_number<float>(str);
      return n.has_value() ? n.value() : NAN;

  # - platform: template
  #   id: num_from_text
  #   name: "Number from text"
  #   unit_of_measurement: "units"
  #   accuracy_decimals: 2

text_sensor:
  - platform: uartex
    id: test_text_sensor
    name: "Test Text Sensor"
    state: "T1"
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars
  - platform: uartex
    id: text_sensor_2
    name: "ATMega Info"
    state: "T2"
    lambda: |-
      return std::string(reinterpret_cast<const char*>(data+2), len-2); // Simply return the received string excluding first 2 chars

binary_sensor:
  - platform: uartex
    state: "B1"
    state_on:
      offset: 2
      data: [0x31] # ASCII '1'
    state_off:
      offset: 2
      data: [0x30] # ASCII '0'
    name: "ATMega Button"
